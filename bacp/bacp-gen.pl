#!/usr/bin/perl -w
# BACP instance generation
# given $n, generate n-vertex digraph with 3 layers
# option for more layers later?

# based on density $p, add edges between layer 1 and 2, and 2 and 3
# create weights in rightish range

use Getopt::Long;
my $n    =   40;
my $per  =   10;
my $lpl  =    2;
my $lpu  =   18;
my $cpl  =    2;
my $cpu  =   10;
my $wmin =    3;
my $wmax =    7;
my $seed =   '';
my $p    =  0.2;
my $f    =   '';
my $help =   '';
GetOptions(
  'n|n_courses=i'                => \$n,
  'per|n_periods=i'              => \$per,
  'lpl|load_per_period_lb=i'     => \$lpl,
  'lpu|load_per_period_ub=i'     => \$lpu,
  'cpl|courses_per_period_lb=i'  => \$cpl,
  'cpu|courses_per_period_ub=i'  => \$cpu,
  'wmin|course_load_min=i'       => \$wmin,
  'wmax|course_load_max=i'       => \$wmax,
  's|seed=i'                     => \$seed,
  'p|probability_of_edge=f'      => \$p,
  'f|force_accept_unsatisfiable' => \$f,
  'h|help'                       => \$help
)
or die("Error in command line arguments\n");
if ($help) {
  my $fv = $f ? 'yes' : 'no';
  my $sv = ($seed or 'unspecified');
  print <<EOT;
The following options take a non-negative integer argument:
  -n | --n_courses [default: $n]
  -per | --n_periods [$per]
  -lpl | --load_per_period_lb [$lpl]
  -lpu | --load_per_period_ub [$lpu]
  -cpl | --courses_per_period_lb [$cpl]
  -cpu | --courses_per_period_ub [$cpu]
  -wmin | --course_load_min [$wmin]
  -wmax | --course_load_max [$wmax]
  -s | --seed [$sv]
-p | --probability_of_edge specifies a real number between 0 and 1 [$p].
-f | --force_accept_unsatisfiable overrides some sanity checks [$fv].
-h or --help prints this message.
EOT
  exit(0);
}

# sanity check that the instance is satisfiable
unless ($f) {
  die( "weights always too large for limits\n" ) if ($wmin * $cpl > $lpu * $cpu );
  die( "weights always too small for limits\n" ) if ($wmax * $cpu < $lpl * $cpl );
}

if ($seed) {
  srand($seed);
} else {
  $seed = srand();
}

print "language Essence 1.3\n";
print '$ generated by bacp-gen.pl with seed ', "$seed\n";
print '$ edge probability ', $p, "\n";
print '$ course loads in range ', $wmin, '..', $wmax, "\n";
print "letting n_courses be $n\n";
print "letting n_periods be $per\n";
print "letting load_per_period_lb be $lpl\n";
print "letting load_per_period_ub be $lpu\n";
print "letting courses_per_period_lb be $cpl\n";
print "letting courses_per_period_ub be $cpu\n";

my @size; # number of vertices in each layer
my @sind; # index of first vertex in each layer, $sind[-1] == $n
$qn = int(($n+1)*0.25); # check offset
$size[0] = int($n*0.125+rand($qn));
$size[2] = int($n*0.125+rand($qn));
$size[1] = $n - $size[0] - $size[2];
# print "layers: @size\n";
my $c = 0;
@sind = map {$c += $_} (0,@size);
# print "layers: @sind\n";

$wr = $wmax - $wmin + 0.5;

sub random_list {
  my $size = shift;
  my @l;
  for (1..$size) {
    push @l, int(rand($wr)) + $wmin;
  }
  return \@l;
}

for $i (0..2) {
  $layers[$i] = random_list($size[$i]);
  #print "@{$layers[$i]}\n";
}
print "letting course_load be function(";
my $sep = '';
my $u = 1;
for $i (0..2) {
  for $w (@{$layers[$i]}) {
    print "$sep\n$u --> $w";
    $sep = ',';
    ++$u;
  }
}
print "\n)\n";

my %e;
my $te = 0;

sub gen_edge {
  my ($u,$v) = @_;
  $e{$u,$v} = 1;
  print "$sep\n(", $u+1, ',', $v+1, ")";
  $sep = ',';
  ++$te;
}

my @me = ($size[1]*$size[0], $size[2]*$size[1]); # max edges in each layer
# my @te = (0,0); # current edges in each layer
# for $i (0..1) {
#   for $u ($sind[$i]..$sind[$i+1]-1) {
#     for $v ($sind[$i+1]..$sind[$i+2]-1) {
#       ++$te[$i] if $e{$u,$v};
#     }
#   }
# }
my $me = 0; # max edges
map {$me += $_} (map {$size[$_+1] * $size[$_]} (0..1));
my $target = int($p * $me);
print '$ layers: ', "@size\n";
print '$ max edges per layer: ', "@me\n";
print '$ generating ', "$target edges\n";

# generate random dependencies to enforce layers
print "letting prerequisite be relation (";
$sep = '';
for $i (1..2) {
  for $v (0..$size[$i]-1) {
    $u = int(rand($size[$i-1])) + $sind[$i-1];
    gen_edge($u,$v + $sind[$i]);
  }
}

# generate random dependencies to reach desired edge density
while ($te < $target) {
  my ($i,$u,$v);
  do {
    $i = int(rand(2));
    $u = int(rand($size[$i])) + $sind[$i];
    $v = int(rand($size[$i+1])) + $sind[$i+1];
  } while ($e{$u,$v});
  gen_edge($u,$v);
}
print "\n)\n";

